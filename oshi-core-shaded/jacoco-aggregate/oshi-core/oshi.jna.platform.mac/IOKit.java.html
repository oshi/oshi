<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IOKit.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">oshi-core-shaded</a> &gt; <a href="../index.html" class="el_bundle">oshi-core</a> &gt; <a href="index.source.html" class="el_package">oshi.jna.platform.mac</a> &gt; <span class="el_source">IOKit.java</span></div><h1>IOKit.java</h1><pre class="source lang-java linenums">/**
 * OSHI (https://github.com/oshi/oshi)
 *
 * Copyright (c) 2010 - 2019 The OSHI Project Team:
 * https://github.com/oshi/oshi/graphs/contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package oshi.jna.platform.mac;

import com.sun.jna.Library;
import com.sun.jna.Memory;
import com.sun.jna.Native;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.Structure;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.LongByReference;
import com.sun.jna.ptr.NativeLongByReference;
import com.sun.jna.ptr.PointerByReference;

import oshi.jna.platform.mac.CoreFoundation.CFAllocatorRef;
import oshi.jna.platform.mac.CoreFoundation.CFArrayRef;
import oshi.jna.platform.mac.CoreFoundation.CFBooleanRef;
import oshi.jna.platform.mac.CoreFoundation.CFDataRef;
import oshi.jna.platform.mac.CoreFoundation.CFDictionaryRef;
import oshi.jna.platform.mac.CoreFoundation.CFMutableDictionaryRef;
import oshi.jna.platform.mac.CoreFoundation.CFNumberRef;
import oshi.jna.platform.mac.CoreFoundation.CFStringRef;
import oshi.jna.platform.mac.CoreFoundation.CFTypeRef;

/**
 * The I/O Kit framework implements non-kernel access to I/O Kit objects
 * (drivers and nubs) through the device-interface mechanism.
 */
public interface IOKit extends Library {

<span class="nc" id="L54">    IOKit INSTANCE = Native.load(&quot;IOKit&quot;, IOKit.class);</span>

    int kIORegistryIterateRecursively = 0x00000001;
    int kIORegistryIterateParents = 0x00000002;

    /**
     * Return value when attempting parent or child in registry and they do not
     * exist
     */
    int kIOReturnNoDevice = 0xe00002c0;

    double kIOPSTimeRemainingUnlimited = -2.0;
    double kIOPSTimeRemainingUnknown = -1.0;

    /**
     * IOKitLib implements non-kernel task access to common IOKit object types -
     * IORegistryEntry, IOService, IOIterator etc. These functions are generic -
     * families may provide API that is more specific.
     * &lt;p&gt;
     * IOKitLib represents IOKit objects outside the kernel with the types
     * io_object_t, io_registry_entry_t, io_service_t, and io_connect_t. Function
     * names usually begin with the type of object they are compatible with - e.g.,
     * IOObjectRelease can be used with any io_object_t. Inside the kernel, the c++
     * class hierarchy allows the subclasses of each object type to receive the same
     * requests from user level clients, for example in the kernel, IOService is a
     * subclass of IORegistryEntry, which means any of the IORegistryEntryXXX
     * functions in IOKitLib may be used with io_service_t's as well as
     * io_registry_t's. There are functions available to introspect the class of the
     * kernel object which any io_object_t et al. represents. IOKit objects returned
     * by all functions should be released with {@link IOKit#IOObjectRelease}.
     */
    class IOObject extends PointerType {
        public IOObject() {
<span class="nc" id="L87">            super();</span>
<span class="nc" id="L88">        }</span>

        public IOObject(Pointer p) {
<span class="nc" id="L91">            super(p);</span>
<span class="nc" id="L92">        }</span>

        /**
         * Convenience method for {@link IOKit#IOObjectConformsTo} on this object.
         *
         * @param className
         *            The name of the class.
         * @return If the object handle is valid, and represents an object in the kernel
         *         that dynamic casts to the class true is returned, otherwise false.
         */
        public boolean conformsTo(String className) {
<span class="nc" id="L103">            return INSTANCE.IOObjectConformsTo(this, className);</span>
        }

        /**
         * Convenience method for {@link IOKit#IOObjectRelease} on this object.
         *
         * @return 0 if successful, otherwise a {@code kern_return_t} error code.
         */
        public int release() {
<span class="nc" id="L112">            return INSTANCE.IOObjectRelease(this);</span>
        }
    }

    /**
     * An IOKit iterator handle.
     */
    class IOIterator extends IOObject {
        public IOIterator() {
<span class="nc" id="L121">            super();</span>
<span class="nc" id="L122">        }</span>

        public IOIterator(Pointer p) {
<span class="nc" id="L125">            super(p);</span>
<span class="nc" id="L126">        }</span>

        /**
         * Convenience method for {@link IOKit#IOIteratorNext} on this object.
         *
         * @return If the iterator handle is valid, the next element in the iteration is
         *         returned, otherwise {@code null} is returned. The element should be
         *         released by the caller when it is finished.
         */
        public IORegistryEntry next() {
<span class="nc" id="L136">            return INSTANCE.IOIteratorNext(this);</span>
        }
    }

    /**
     * The base class for all objects in the registry.
     */
    class IORegistryEntry extends IOObject {
        public IORegistryEntry() {
<span class="nc" id="L145">            super();</span>
<span class="nc" id="L146">        }</span>

        public IORegistryEntry(Pointer p) {
<span class="nc" id="L149">            super(p);</span>
<span class="nc" id="L150">        }</span>

        /**
         * Convenience method for {@link #IORegistryEntryGetRegistryEntryID} to return
         * an ID for this registry entry that is global to all tasks.
         *
         * @return the ID.
         * @throws IOReturnException
         *             if the ID could not be retrieved.
         */
        public long getRegistryEntryID() {
<span class="nc" id="L161">            LongByReference id = new LongByReference();</span>
<span class="nc" id="L162">            int kr = INSTANCE.IORegistryEntryGetRegistryEntryID(this, id);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">            if (kr != 0) {</span>
<span class="nc" id="L164">                throw new IOReturnException(kr);</span>
            }
<span class="nc" id="L166">            return id.getValue();</span>
        }

        /**
         * Convenience method for {@link #IORegistryEntryGetName} to return a name
         * assigned to this registry entry.
         *
         * @return The name
         * @throws IOReturnException
         *             if the name could not be retrieved.
         */
        public String getName() {
<span class="nc" id="L178">            Memory name = new Memory(128);</span>
<span class="nc" id="L179">            int kr = INSTANCE.IORegistryEntryGetName(this, name);</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">            if (kr != 0) {</span>
<span class="nc" id="L181">                throw new IOReturnException(kr);</span>
            }
<span class="nc" id="L183">            return name.getString(0);</span>
        }

        /**
         * Convenience method for {@link #IORegistryEntryGetChildIterator} to return an
         * iterator over this registry entry’s child entries in a plane.
         *
         * @param plane
         *            The name of an existing registry plane. Plane names are defined in
         *            {@code IOKitKeys.h}, for example, {@code kIOServicePlane}.
         * @return The iterator
         * @throws IOReturnException
         *             if the iterator could not be retrieved.
         */
        public IOIterator getChildIterator(String plane) {
<span class="nc" id="L198">            PointerByReference iter = new PointerByReference();</span>
<span class="nc" id="L199">            int kr = INSTANCE.IORegistryEntryGetChildIterator(this, plane, iter);</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            if (kr != 0) {</span>
<span class="nc" id="L201">                throw new IOReturnException(kr);</span>
            }
<span class="nc" id="L203">            return new IOIterator(iter.getValue());</span>
        }

        /**
         * Convenience method for {@link #IORegistryEntryGetChildEntry} to return the
         * first child of this registry entry in a plane.
         *
         * @param plane
         *            The name of an existing registry plane.
         * @return The child registry entry, if a child exists, null otherwise
         * @throws IOReturnException
         *             if the entry exists but could not be retrieved.
         */
        public IORegistryEntry getChildEntry(String plane) {
<span class="nc" id="L217">            PointerByReference child = new PointerByReference();</span>
<span class="nc" id="L218">            int kr = INSTANCE.IORegistryEntryGetChildEntry(this, plane, child);</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            if (kr == kIOReturnNoDevice) {</span>
<span class="nc" id="L220">                return null;</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">            } else if (kr != 0) {</span>
<span class="nc" id="L222">                throw new IOReturnException(kr);</span>
            }
<span class="nc" id="L224">            return new IORegistryEntry(child.getValue());</span>
        }

        /**
         * Convenience method for {@link #IORegistryEntryGetParentEntry} to return the
         * first parent of this registry entry in a plane.
         *
         * @param plane
         *            The name of an existing registry plane.
         * @return The parent registry entry, if a parent exists, null otherwise
         * @throws IOReturnException
         *             if the entry exists but could not be retrieved.
         */
        public IORegistryEntry getParentEntry(String plane) {
<span class="nc" id="L238">            PointerByReference parent = new PointerByReference();</span>
<span class="nc" id="L239">            int kr = INSTANCE.IORegistryEntryGetParentEntry(this, plane, parent);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">            if (kr == kIOReturnNoDevice) {</span>
<span class="nc" id="L241">                return null;</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">            } else if (kr != 0) {</span>
<span class="nc" id="L243">                throw new IOReturnException(kr);</span>
            }
<span class="nc" id="L245">            return new IORegistryEntry(parent.getValue());</span>
        }

        /**
         * Convenience method for {@link #IORegistryEntryCreateCFProperty} to create a
         * CF representation of this registry entry's property.
         *
         * @param key
         *            A {@code CFString} specifying the property name.
         * @return A CF container is created and returned the caller on success.
         *         &lt;p&gt;
         *         The caller should release with {@link CoreFoundation#CFRelease}.
         */
        public CFTypeRef createCFProperty(CFStringRef key) {
<span class="nc" id="L259">            return INSTANCE.IORegistryEntryCreateCFProperty(this, key, CoreFoundation.INSTANCE.CFAllocatorGetDefault(),</span>
                    0);
        }

        /**
         * Convenience method for {@link #IORegistryEntryCreateCFProperties} to create a
         * CF dictionary representation of this registry entry's property table.
         *
         * @return The property table.
         *         &lt;p&gt;
         *         The caller should release with {@link CoreFoundation#CFRelease}.
         * @throws IOReturnException
         *             if the entry could not be retrieved.
         */
        public CFMutableDictionaryRef createCFProperties() {
<span class="nc" id="L274">            PointerByReference properties = new PointerByReference();</span>
<span class="nc" id="L275">            int kr = INSTANCE.IORegistryEntryCreateCFProperties(this, properties,</span>
<span class="nc" id="L276">                    CoreFoundation.INSTANCE.CFAllocatorGetDefault(), 0);</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">            if (kr != 0) {</span>
<span class="nc" id="L278">                throw new IOReturnException(kr);</span>
            }
<span class="nc" id="L280">            return new CFMutableDictionaryRef(properties.getValue());</span>
        }

        /**
         * Convenience method for {@link #IORegistryEntrySearchCFProperty} to create a
         * CF representation of a registry entry's property searched from this object.
         *
         * @param plane
         *            The name of an existing registry plane. Plane names are defined in
         *            {@code IOKitKeys.h}, for example, {@code kIOServicePlane}.
         * @param key
         *            A {@code CFString} specifying the property name.
         * @param options
         *            {@link #kIORegistryIterateRecursively} may be set to recurse
         *            automatically into the registry hierarchy. Without this option,
         *            this method degenerates into the standard
         *            {@link #IORegistryEntryCreateCFProperty} call.
         *            {@link #kIORegistryIterateParents} may be set to iterate the
         *            parents of the entry, in place of the children.
         * @return A CF container is created and returned the caller on success. The
         *         caller should release with CFRelease.
         */
        CFTypeRef searchCFProperty(String plane, CFStringRef key, int options) {
<span class="nc" id="L303">            return INSTANCE.IORegistryEntrySearchCFProperty(this, plane, key,</span>
<span class="nc" id="L304">                    CoreFoundation.INSTANCE.CFAllocatorGetDefault(), options);</span>
        }

        /**
         * Convenience method to get a {@link java.lang.String} value from this IO
         * Registry Entry.
         *
         * @param key
         *            The string name of the key to retrieve
         * @return The value of the registry entry if it exists; {@code null} otherwise
         */
        public String getStringProperty(String key) {
<span class="nc" id="L316">            String value = null;</span>
<span class="nc" id="L317">            CFStringRef keyAsCFString = CFStringRef.createCFString(key);</span>
<span class="nc" id="L318">            CFTypeRef valueAsCFType = this.createCFProperty(keyAsCFString);</span>
<span class="nc" id="L319">            keyAsCFString.release();</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">            if (valueAsCFType != null) {</span>
<span class="nc" id="L321">                CFStringRef valueAsCFString = new CFStringRef(valueAsCFType.getPointer());</span>
<span class="nc" id="L322">                value = valueAsCFString.stringValue();</span>
<span class="nc" id="L323">                valueAsCFType.release();</span>
            }
<span class="nc" id="L325">            return value;</span>
        }

        /**
         * Convenience method to get a {@link java.lang.Long} value from this IO
         * Registry Entry.
         *
         * @param key
         *            The string name of the key to retrieve
         * @return The value of the registry entry if it exists; {@code null} otherwise
         *         &lt;p&gt;
         *         This method assumes a 64-bit integer is stored and does not do type
         *         checking. If this object's type differs from the return type, and the
         *         conversion is lossy or the return value is out of range, then this
         *         method returns an approximate value.
         */
        public Long getLongProperty(String key) {
<span class="nc" id="L342">            Long value = null;</span>
<span class="nc" id="L343">            CFStringRef keyAsCFString = CFStringRef.createCFString(key);</span>
<span class="nc" id="L344">            CFTypeRef valueAsCFType = this.createCFProperty(keyAsCFString);</span>
<span class="nc" id="L345">            keyAsCFString.release();</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">            if (valueAsCFType != null) {</span>
<span class="nc" id="L347">                CFNumberRef valueAsCFNumber = new CFNumberRef(valueAsCFType.getPointer());</span>
<span class="nc" id="L348">                value = valueAsCFNumber.longValue();</span>
<span class="nc" id="L349">                valueAsCFType.release();</span>
            }
<span class="nc" id="L351">            return value;</span>
        }

        /**
         * Convenience method to get an {@link java.lang.Integer} value from this IO
         * Registry Entry.
         *
         * @param key
         *            The string name of the key to retrieve
         * @return The value of the registry entry if it exists; {@code null} otherwise
         *         &lt;p&gt;
         *         This method assumes a 32-bit integer is stored and does not do type
         *         checking. If this object's type differs from the return type, and the
         *         conversion is lossy or the return value is out of range, then this
         *         method returns an approximate value.
         */
        public Integer getIntegerProperty(String key) {
<span class="nc" id="L368">            Integer value = null;</span>
<span class="nc" id="L369">            CFStringRef keyAsCFString = CFStringRef.createCFString(key);</span>
<span class="nc" id="L370">            CFTypeRef valueAsCFType = this.createCFProperty(keyAsCFString);</span>
<span class="nc" id="L371">            keyAsCFString.release();</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">            if (valueAsCFType != null) {</span>
<span class="nc" id="L373">                CFNumberRef valueAsCFNumber = new CFNumberRef(valueAsCFType.getPointer());</span>
<span class="nc" id="L374">                value = valueAsCFNumber.intValue();</span>
<span class="nc" id="L375">                valueAsCFType.release();</span>
            }
<span class="nc" id="L377">            return value;</span>
        }

        /**
         * Convenience method to get a {@link java.lang.Double} value from this IO
         * Registry Entry.
         *
         * @param key
         *            The string name of the key to retrieve
         * @return The value of the registry entry if it exists; {@code null} otherwise
         *         &lt;p&gt;
         *         This method assumes a floating point value is stored and does not do
         *         type checking. If this object's type differs from the return type,
         *         and the conversion is lossy or the return value is out of range, then
         *         this method returns an approximate value.
         */
        public Double getDoubleProperty(String key) {
<span class="nc" id="L394">            Double value = null;</span>
<span class="nc" id="L395">            CFStringRef keyAsCFString = CFStringRef.createCFString(key);</span>
<span class="nc" id="L396">            CFTypeRef valueAsCFType = this.createCFProperty(keyAsCFString);</span>
<span class="nc" id="L397">            keyAsCFString.release();</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">            if (valueAsCFType != null) {</span>
<span class="nc" id="L399">                CFNumberRef valueAsCFNumber = new CFNumberRef(valueAsCFType.getPointer());</span>
<span class="nc" id="L400">                value = valueAsCFNumber.doubleValue();</span>
<span class="nc" id="L401">                valueAsCFType.release();</span>
            }
<span class="nc" id="L403">            return value;</span>
        }

        /**
         * Convenience method to get a {@link java.lang.Boolean} value from this IO
         * Registry Entry.
         *
         * @param key
         *            The string name of the key to retrieve
         * @return The value of the registry entry if it exists; {@code null} otherwise
         */
        public Boolean getBooleanProperty(String key) {
<span class="nc" id="L415">            Boolean value = null;</span>
<span class="nc" id="L416">            CFStringRef keyAsCFString = CFStringRef.createCFString(key);</span>
<span class="nc" id="L417">            CFTypeRef valueAsCFType = this.createCFProperty(keyAsCFString);</span>
<span class="nc" id="L418">            keyAsCFString.release();</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">            if (valueAsCFType != null) {</span>
<span class="nc" id="L420">                CFBooleanRef valueAsCFBoolean = new CFBooleanRef(valueAsCFType.getPointer());</span>
<span class="nc" id="L421">                value = valueAsCFBoolean.booleanValue();</span>
<span class="nc" id="L422">                valueAsCFType.release();</span>
            }
<span class="nc" id="L424">            return value;</span>
        }

        /**
         * Convenience method to get a {@code byte} array value from this IO Registry
         * Entry.
         *
         * @param key
         *            The string name of the key to retrieve
         * @return The value of the registry entry if it exists; {@code null} otherwise
         */
        public byte[] getByteArrayProperty(String key) {
<span class="nc" id="L436">            byte[] value = null;</span>
<span class="nc" id="L437">            CFStringRef keyAsCFString = CFStringRef.createCFString(key);</span>
<span class="nc" id="L438">            CFTypeRef valueAsCFType = this.createCFProperty(keyAsCFString);</span>
<span class="nc" id="L439">            keyAsCFString.release();</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">            if (valueAsCFType != null) {</span>
<span class="nc" id="L441">                CFDataRef valueAsCFData = new CFDataRef(valueAsCFType.getPointer());</span>
<span class="nc" id="L442">                int length = valueAsCFData.getLength();</span>
<span class="nc" id="L443">                Pointer p = valueAsCFData.getBytePtr();</span>
<span class="nc" id="L444">                value = p.getByteArray(0, length);</span>
<span class="nc" id="L445">                valueAsCFType.release();</span>
            }
<span class="nc" id="L447">            return value;</span>
        }
    }

    /**
     * The base class for most I/O Kit families, devices, and drivers.
     */
    class IOService extends IORegistryEntry {
        public IOService() {
<span class="nc" id="L456">            super();</span>
<span class="nc" id="L457">        }</span>

        public IOService(Pointer p) {
<span class="nc" id="L460">            super(p);</span>
<span class="nc" id="L461">        }</span>
    }

    /**
     * For an application to communicate with a device, the first thing it must do
     * is create a connection between itself and the in-kernel object representing
     * the device. To do this, it creates a user client object.
     */
    class IOConnect extends IOService {
        public IOConnect() {
<span class="nc" id="L471">            super();</span>
<span class="nc" id="L472">        }</span>

        public IOConnect(Pointer p) {
<span class="nc" id="L475">            super(p);</span>
<span class="nc" id="L476">        }</span>
    }

    /**
     * Returns the mach port used to initiate communication with IOKit.
     *
     * @param bootstrapPort
     *            Pass 0 for the default.
     * @param port
     *            A pointer to the master port is returned. Multiple calls to
     *            IOMasterPort will not result in leaking ports (each call to
     *            IOMasterPort adds another send right to the port) but it is
     *            considered good programming practice to deallocate the port when
     *            you are finished with it using
     *            {@link oshi.jna.platform.mac.SystemB#mach_port_deallocate}.
     * @return 0 if successful, otherwise a {@code kern_return_t} error code.
     */
    int IOMasterPort(int bootstrapPort, IntByReference port);

    /**
     * Create a matching dictionary that specifies an {@code IOService} class match.
     *
     * @param name
     *            The class name. Class matching is successful on {@code IOService}s
     *            of this class or any subclass.
     * @return The matching dictionary created, is returned on success, or
     *         {@code null} on failure.
     *         &lt;p&gt;
     *         The dictionary is commonly passed to
     *         {@link #IOServiceGetMatchingServices} which will consume a reference,
     *         otherwise it should be released with {@link CoreFoundation#CFRelease}
     *         by the caller.
     */
    CFMutableDictionaryRef IOServiceMatching(String name);

    /**
     * Create a matching dictionary that specifies an {@code IOService} name match.
     *
     * @param name
     *            The {@code IOService} name.
     * @return The matching dictionary created, is returned on success, or
     *         {@code null} on failure.
     *         &lt;p&gt;
     *         The dictionary is commonly passed to
     *         {@link #IOServiceGetMatchingServices} which will consume a reference,
     *         otherwise it should be released with {@link CoreFoundation#CFRelease}
     *         by the caller.
     */
    CFMutableDictionaryRef IOServiceNameMatching(String name);

    /**
     * Create a matching dictionary that specifies an {@code IOService} match based
     * on BSD device name.
     *
     * @param masterPort
     *            The master port obtained from {@link #IOMasterPort}.
     * @param options
     *            No options are currently defined.
     * @param bsdName
     *            The BSD name.
     * @return The matching dictionary created, is returned on success, or
     *         {@code null} on failure.
     *         &lt;p&gt;
     *         The dictionary is commonly passed to
     *         {@link #IOServiceGetMatchingServices} which will consume a reference,
     *         otherwise it should be released with {@link CoreFoundation#CFRelease}
     *         by the caller.
     */
    CFMutableDictionaryRef IOBSDNameMatching(int masterPort, int options, String bsdName);

    /**
     * Look up a registered IOService object that matches a matching dictionary.
     *
     * @param masterPort
     *            The master port obtained from {@link #IOMasterPort}.
     * @param matchingDictionary
     *            A CF dictionary containing matching information, of which one
     *            reference is always consumed by this function. IOKitLib can
     *            construct matching dictionaries for common criteria with helper
     *            functions such as {@link #IOServiceMatching},
     *            {@link #IOServiceNameMatching}, and {@link #IOBSDNameMatching}.
     * @return The first service matched is returned on success.
     *         &lt;p&gt;
     *         The service must be released by the caller.
     */
    IOService IOServiceGetMatchingService(int masterPort, CFDictionaryRef matchingDictionary);

    /**
     * Look up registered IOService objects that match a matching dictionary.
     *
     * @param masterPort
     *            The master port obtained from {@link #IOMasterPort}.
     * @param matchingDictionary
     *            A CF dictionary containing matching information, of which one
     *            reference is always consumed by this function. IOKitLib can
     *            construct matching dictionaries for common criteria with helper
     *            functions such as {@link #IOServiceMatching},
     *            {@link #IOServiceNameMatching}, and {@link #IOBSDNameMatching}.
     * @param iterator
     *            An iterator handle is returned on success, and should be released
     *            by the caller when the iteration is finished.
     * @return 0 if successful, otherwise a {@code kern_return_t} error code.
     */
    int IOServiceGetMatchingServices(int masterPort, CFDictionaryRef matchingDictionary, PointerByReference iterator);

    /**
     * Returns the next object in an iteration.
     *
     * @param iterator
     *            An IOKit iterator handle.
     * @return If the iterator handle is valid, the next element in the iteration is
     *         returned, otherwise zero is returned. The element should be released
     *         by the caller when it is finished.
     */
    IORegistryEntry IOIteratorNext(IOIterator iterator);

    /**
     * Create a CF representation of a registry entry's property.
     *
     * @param entry
     *            The registry entry handle whose property to copy.
     * @param key
     *            A {@code CFString} specifying the property name.
     * @param allocator
     *            The CF allocator to use when creating the CF container.
     * @param options
     *            No options are currently defined.
     * @return A CF container is created and returned the caller on success.
     *         &lt;p&gt;
     *         The caller should release with {@link CoreFoundation#CFRelease}.
     */
    CFTypeRef IORegistryEntryCreateCFProperty(IORegistryEntry entry, CFStringRef key, CFAllocatorRef allocator,
            int options);

    /**
     * Create a CF dictionary representation of a registry entry's property table.
     *
     * @param entry
     *            The registry entry handle whose property table to copy.
     * @param properties
     *            A CFDictionary is created and returned the caller on success. The
     *            caller should release with CFRelease.
     * @param allocator
     *            The CF allocator to use when creating the CF containers.
     * @param options
     *            No options are currently defined.
     * @return 0 if successful, otherwise a {@code kern_return_t} error code.
     */
    int IORegistryEntryCreateCFProperties(IORegistryEntry entry, PointerByReference properties,
            CFAllocatorRef allocator, int options);

    /**
     * Create a CF representation of a registry entry's property.
     *
     * @param entry
     *            The registry entry at which to start the search.
     * @param plane
     *            The name of an existing registry plane. Plane names are defined in
     *            {@code IOKitKeys.h}, for example, {@code kIOServicePlane}.
     * @param key
     *            A {@code CFString} specifying the property name.
     * @param allocator
     *            The CF allocator to use when creating the CF container.
     * @param options
     *            {@link #kIORegistryIterateRecursively} may be set to recurse
     *            automatically into the registry hierarchy. Without this option,
     *            this method degenerates into the standard
     *            {@link #IORegistryEntryCreateCFProperty} call.
     *            {@link #kIORegistryIterateParents} may be set to iterate the
     *            parents of the entry, in place of the children.
     * @return A CF container is created and returned the caller on success. The
     *         caller should release with CFRelease.
     */
    CFTypeRef IORegistryEntrySearchCFProperty(IORegistryEntry entry, String plane, CFStringRef key,
            CFAllocatorRef allocator, int options);

    /**
     * Returns an ID for the registry entry that is global to all tasks.
     *
     * @param entry
     *            The registry entry handle whose ID to look up.
     * @param id
     *            The resulting ID.
     * @return 0 if successful, otherwise a {@code kern_return_t} error code.
     */
    int IORegistryEntryGetRegistryEntryID(IORegistryEntry entry, LongByReference id);

    /**
     * Returns a name assigned to a registry entry.
     *
     * @param entry
     *            The registry entry handle whose name to look up.
     * @param name
     *            The caller's buffer to receive the name. This must be a 128-byte
     *            buffer.
     * @return 0 if successful, otherwise a {@code kern_return_t} error code.
     */
    int IORegistryEntryGetName(IORegistryEntry entry, Pointer name);

    /**
     * Returns an iterator over a registry entry’s child entries in a plane.
     *
     * @param entry
     *            The registry entry whose children to iterate over.
     * @param plane
     *            The name of an existing registry plane. Plane names are defined in
     *            {@code IOKitKeys.h}, for example, {@code kIOServicePlane}.
     * @param iter
     *            The created iterator over the children of the entry, on success.
     *            The iterator must be released when the iteration is finished.
     * @return 0 if successful, otherwise a {@code kern_return_t} error code.
     */
    int IORegistryEntryGetChildIterator(IORegistryEntry entry, String plane, PointerByReference iter);

    /**
     * Returns the first child of a registry entry in a plane.
     *
     * @param entry
     *            The registry entry whose child to look up.
     * @param plane
     *            The name of an existing registry plane. Plane names are defined in
     *            {@code IOKitKeys.h}, for example, {@code kIOServicePlane}.
     * @param child
     *            The first child of the registry entry, on success. The child must
     *            be released by the caller.
     * @return 0 if successful, otherwise a {@code kern_return_t} error code.
     */
    int IORegistryEntryGetChildEntry(IORegistryEntry entry, String plane, PointerByReference child);

    /**
     * Returns the first parent of a registry entry in a plane.
     *
     * @param entry
     *            The registry entry whose parent to look up.
     * @param plane
     *            The name of an existing registry plane. Plane names are defined in
     *            {@code IOKitKeys.h}, for example, {@code kIOServicePlane}.
     * @param parent
     *            The first parent of the registry entry, on success. The parent
     *            must be released by the caller.
     * @return 0 if successful, otherwise a {@code kern_return_t} error code.
     */
    int IORegistryEntryGetParentEntry(IORegistryEntry entry, String plane, PointerByReference parent);

    /**
     * Return a handle to the registry root.
     *
     * @param masterPort
     *            The master port obtained from {@link #IOMasterPort}.
     * @return A handle to the IORegistryEntry root instance, to be released with
     *         {@link #IOObjectRelease} by the caller, or 0 on failure.
     */
    IORegistryEntry IORegistryGetRootEntry(int masterPort);

    /**
     * Performs an OSDynamicCast operation on an IOKit object.
     *
     * @param object
     *            An IOKit object.
     * @param className
     *            The name of the class.
     * @return If the object handle is valid, and represents an object in the kernel
     *         that dynamic casts to the class true is returned, otherwise false.
     */
    boolean IOObjectConformsTo(IOObject object, String className);

    /**
     * Releases an object handle previously returned by {@code IOKitLib}.
     *
     * @param object
     *            The IOKit object to release.
     * @return 0 if successful, otherwise a {@code kern_return_t} error code.
     */
    int IOObjectRelease(IOObject object);

    /**
     * A request to create a connection to an IOService.
     *
     * @param service
     *            The IOService object to open a connection to, usually obtained via
     *            the {@link #IOServiceGetMatchingServices} API.
     * @param owningTask
     *            The mach task requesting the connection.
     * @param type
     *            A constant specifying the type of connection to be created,
     *            interpreted only by the IOService's family.
     * @param connect
     *            An {@code io_connect_t} handle is returned on success, to be used
     *            with the IOConnectXXX APIs. It should be destroyed with
     *            {@link IOServiceClose}.
     * @return A return code generated by {@code IOService::newUserClient}.
     */
    int IOServiceOpen(IOService service, int owningTask, int type, PointerByReference connect);

    /**
     * Returns the busyState of an IOService.
     *
     * @param service
     *            The IOService whose busyState to return.
     * @param busyState
     *            The busyState count is returned.
     * @return 0 if successful, otherwise a {@code kern_return_t} error code.
     */
    int IOServiceGetBusyState(IOService service, IntByReference busyState);

    /**
     * Close a connection to an IOService and destroy the connect handle.
     *
     * @param connect
     *            The connect handle created by IOServiceOpen. It will be destroyed
     *            by this function, and should not be released with IOObjectRelease.
     * @return 0 if successful, otherwise a {@code kern_return_t} error code.
     */
    int IOServiceClose(IOConnect connect);

    /**
     * Returns a blob of Power Source information in an opaque CFTypeRef.
     *
     * @return {@code null} if errors were encountered, a {@link CFTypeRef}
     *         otherwise.
     *         &lt;p&gt;
     *         Caller must {@link CoreFoundation#CFRelease} the return value when
     *         done accessing it.
     */
    CFTypeRef IOPSCopyPowerSourcesInfo();

    /**
     * Returns a CFArray of Power Source handles, each of type CFTypeRef.
     *
     * @param blob
     *            Takes the {@link CFTypeRef} returned by
     *            {@link #IOPSCopyPowerSourcesInfo}
     * @return {@code null} if errors were encountered, otherwise a CFArray of
     *         {@link CFTypeRef}s.
     *         &lt;p&gt;
     *         Caller must {@link CoreFoundation#CFRelease} the returned
     *         {@link CFArrayRef}.
     */
    CFArrayRef IOPSCopyPowerSourcesList(CFTypeRef blob);

    /**
     * Returns a CFDictionary with readable information about the specific power
     * source.
     *
     * @param blob
     *            the {@link CFTypeRef} returned by
     *            {@link #IOPSCopyPowerSourcesInfo}
     * @param ps
     *            One of the {@link CFTypeRef}s in the CFArray returned by
     *            {@link #IOPSCopyPowerSourcesList}.
     * @return {@code null} if an error was encountered, otherwise a CFDictionary.
     *         &lt;p&gt;
     *         Caller should NOT release the returned CFDictionary - it will be
     *         released as part of the {@link CFTypeRef} returned by
     *         {@link IOPSCopyPowerSourcesInfo}.
     */
    CFDictionaryRef IOPSGetPowerSourceDescription(CFTypeRef blob, CFTypeRef ps);

    /**
     * Returns the estimated seconds remaining until all power sources (battery
     * and/or UPS's) are empty.
     *
     * @return Returns {@link #kIOPSTimeRemainingUnknown} if the OS cannot determine
     *         the time remaining.
     *         &lt;p&gt;
     *         Returns {@link #kIOPSTimeRemainingUnlimited} if the system has an
     *         unlimited power source.
     *         &lt;p&gt;
     *         Otherwise returns a positive number indicating the time remaining in
     *         seconds until all power sources are depleted.
     */
    double IOPSGetTimeRemainingEstimate();

    /*
     * Beta/Non-API do not commit to JNA
     */
    int IOConnectCallStructMethod(IOConnect connection, int selector, Structure inputStructure,
            NativeLong structureInputSize, Structure outputStructure, NativeLongByReference structureOutputSize);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>